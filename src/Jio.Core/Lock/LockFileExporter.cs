using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;
using Jio.Core.Models;
using Jio.Core.Resolution;

namespace Jio.Core.Lock;

public interface ILockFileExporter
{
    Task ExportAsync(DependencyGraph graph, string targetPath, LockFileFormat format, CancellationToken cancellationToken = default);
}

public enum LockFileFormat
{
    Npm,
    Yarn,
    YarnBerry,
    Pnpm,
    Jio
}

public class LockFileExporter : ILockFileExporter
{
    private readonly JsonSerializerOptions _jsonOptions;

    public LockFileExporter()
    {
        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }

    public async Task ExportAsync(DependencyGraph graph, string targetPath, LockFileFormat format, CancellationToken cancellationToken = default)
    {
        var content = format switch
        {
            LockFileFormat.Npm => await GenerateNpmLockFileAsync(graph, cancellationToken),
            LockFileFormat.Yarn => await GenerateYarnLockFileAsync(graph, cancellationToken),
            LockFileFormat.YarnBerry => await GenerateYarnBerryLockFileAsync(graph, cancellationToken),
            LockFileFormat.Pnpm => await GeneratePnpmLockFileAsync(graph, cancellationToken),
            LockFileFormat.Jio => await GenerateJioLockFileAsync(graph, cancellationToken),
            _ => throw new NotSupportedException($"Lock file format {format} is not supported")
        };

        await File.WriteAllTextAsync(targetPath, content, cancellationToken);
    }

    private Task<string> GenerateNpmLockFileAsync(DependencyGraph graph, CancellationToken cancellationToken)
    {
        var npmLock = new JsonObject
        {
            ["name"] = graph.Name ?? "project",
            ["version"] = graph.Version ?? "1.0.0",
            ["lockfileVersion"] = 3,
            ["requires"] = true
        };

        var packages = new JsonObject();
        
        // Add root package
        var rootPackage = new JsonObject
        {
            ["name"] = graph.Name ?? "project",
            ["version"] = graph.Version ?? "1.0.0"
        };

        if (graph.Dependencies.Any())
        {
            rootPackage["dependencies"] = new JsonObject(
                graph.Dependencies.Select(d => new KeyValuePair<string, JsonNode?>(d.Key, JsonValue.Create(d.Value)))
            );
        }

        if (graph.DevDependencies.Any())
        {
            rootPackage["devDependencies"] = new JsonObject(
                graph.DevDependencies.Select(d => new KeyValuePair<string, JsonNode?>(d.Key, JsonValue.Create(d.Value)))
            );
        }

        if (graph.OptionalDependencies.Any())
        {
            rootPackage["optionalDependencies"] = new JsonObject(
                graph.OptionalDependencies.Select(d => new KeyValuePair<string, JsonNode?>(d.Key, JsonValue.Create(d.Value)))
            );
        }

        packages[""] = rootPackage;

        // Add all resolved packages
        foreach (var package in graph.Packages.Values)
        {
            var packageNode = new JsonObject
            {
                ["version"] = package.Version,
                ["resolved"] = package.Resolved,
                ["integrity"] = package.Integrity
            };

            if (package.Dependencies.Any())
            {
                packageNode["dependencies"] = new JsonObject(
                    package.Dependencies.Select(d => new KeyValuePair<string, JsonNode?>(d.Key, JsonValue.Create(d.Value)))
                );
            }

            if (package.Dev)
            {
                packageNode["dev"] = true;
            }

            if (package.Optional)
            {
                packageNode["optional"] = true;
            }

            packages[$"node_modules/{package.Name}"] = packageNode;
        }

        npmLock["packages"] = packages;

        return Task.FromResult(npmLock.ToJsonString(_jsonOptions));
    }

    private Task<string> GenerateYarnLockFileAsync(DependencyGraph graph, CancellationToken cancellationToken)
    {
        var sb = new StringBuilder();
        sb.AppendLine("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.");
        sb.AppendLine("# yarn lockfile v1");
        sb.AppendLine();

        // Group packages by name and version range
        var packageGroups = new Dictionary<string, List<(string versionRange, ResolvedPackage package)>>();
        
        // Process all dependencies to find version ranges
        ProcessDependencies(graph.Dependencies, graph.Packages, packageGroups);
        ProcessDependencies(graph.DevDependencies, graph.Packages, packageGroups);
        ProcessDependencies(graph.OptionalDependencies, graph.Packages, packageGroups);

        // Write each package group
        foreach (var group in packageGroups.OrderBy(g => g.Key))
        {
            foreach (var (versionRange, package) in group.Value)
            {
                sb.AppendLine($"{package.Name}@{versionRange}:");
                sb.AppendLine($"  version \"{package.Version}\"");
                sb.AppendLine($"  resolved \"{package.Resolved}\"");
                
                // Convert integrity to Yarn format (remove algorithm prefix)
                var integrity = package.Integrity;
                if (package.Integrity.StartsWith("sha512-"))
                {
                    integrity = package.Integrity.Substring(7);
                }
                else if (package.Integrity.StartsWith("sha1-"))
                {
                    integrity = package.Integrity.Substring(5);
                }
                sb.AppendLine($"  integrity {integrity}");

                if (package.Dependencies.Any())
                {
                    sb.AppendLine("  dependencies:");
                    foreach (var dep in package.Dependencies.OrderBy(d => d.Key))
                    {
                        sb.AppendLine($"    {dep.Key} \"{dep.Value}\"");
                    }
                }

                sb.AppendLine();
            }
        }

        return Task.FromResult(sb.ToString());
    }

    private Task<string> GenerateYarnBerryLockFileAsync(DependencyGraph graph, CancellationToken cancellationToken)
    {
        var sb = new StringBuilder();
        sb.AppendLine("# This file is generated by running \"yarn install\" inside your project.");
        sb.AppendLine("# Manual changes might be lost - proceed with caution!");
        sb.AppendLine();
        sb.AppendLine("__metadata:");
        sb.AppendLine("  version: 6");
        sb.AppendLine();

        // Group packages by name to handle multiple version ranges
        var packagesByName = new Dictionary<string, List<(string version, ResolvedPackage package)>>();
        
        foreach (var (key, package) in graph.Packages)
        {
            if (!packagesByName.ContainsKey(package.Name))
            {
                packagesByName[package.Name] = new List<(string, ResolvedPackage)>();
            }
            packagesByName[package.Name].Add((package.Version, package));
        }

        // Write each package entry
        foreach (var (name, versions) in packagesByName.OrderBy(p => p.Key))
        {
            foreach (var (version, package) in versions)
            {
                // Find version ranges that resolve to this version
                var versionRanges = new List<string>();
                
                // Check direct dependencies
                if (graph.Dependencies.ContainsKey(name))
                {
                    versionRanges.Add(graph.Dependencies[name]);
                }
                if (graph.DevDependencies.ContainsKey(name))
                {
                    versionRanges.Add(graph.DevDependencies[name]);
                }
                
                // If no version ranges found, use exact version
                if (!versionRanges.Any())
                {
                    versionRanges.Add($"^{version}");
                }

                // Write entry header
                sb.AppendLine($"\"{name}@npm:{string.Join(", ", versionRanges.Distinct())}\":");
                sb.AppendLine($"  version: {version}");
                sb.AppendLine($"  resolution: \"{name}@npm:{version}\"");
                
                // Write dependencies if any
                if (package.Dependencies.Any())
                {
                    sb.AppendLine("  dependencies:");
                    foreach (var dep in package.Dependencies.OrderBy(d => d.Key))
                    {
                        sb.AppendLine($"    {dep.Key}: {dep.Value}");
                    }
                }
                
                // Extract checksum from integrity
                var checksum = "";
                if (!string.IsNullOrEmpty(package.Integrity))
                {
                    if (package.Integrity.StartsWith("sha512-"))
                    {
                        checksum = package.Integrity.Substring(7);
                    }
                    else if (package.Integrity.StartsWith("sha1-"))
                    {
                        // Convert sha1 to hex format if needed
                        checksum = package.Integrity.Substring(5);
                    }
                }
                
                sb.AppendLine($"  checksum: {checksum}");
                sb.AppendLine("  languageName: node");
                sb.AppendLine("  linkType: hard");
                sb.AppendLine();
            }
        }

        return Task.FromResult(sb.ToString());
    }

    private Task<string> GeneratePnpmLockFileAsync(DependencyGraph graph, CancellationToken cancellationToken)
    {
        var pnpmLock = new Dictionary<string, object>
        {
            ["lockfileVersion"] = "6.0",
            ["settings"] = new Dictionary<string, object>
            {
                ["autoInstallPeers"] = true,
                ["excludeLinksFromLockfile"] = false
            }
        };

        // Dependencies section
        var dependencies = new Dictionary<string, object>();
        foreach (var dep in graph.Dependencies)
        {
            var package = graph.Packages.Values.FirstOrDefault(p => p.Name == dep.Key);
            if (package != null)
            {
                dependencies[dep.Key] = new Dictionary<string, object>
                {
                    ["specifier"] = dep.Value,
                    ["version"] = package.Version
                };
            }
        }

        if (dependencies.Any())
        {
            pnpmLock["dependencies"] = dependencies;
        }

        // DevDependencies section
        var devDependencies = new Dictionary<string, object>();
        foreach (var dep in graph.DevDependencies)
        {
            var package = graph.Packages.Values.FirstOrDefault(p => p.Name == dep.Key);
            if (package != null)
            {
                devDependencies[dep.Key] = new Dictionary<string, object>
                {
                    ["specifier"] = dep.Value,
                    ["version"] = package.Version
                };
            }
        }

        if (devDependencies.Any())
        {
            pnpmLock["devDependencies"] = devDependencies;
        }

        // Packages section
        var packages = new Dictionary<string, object>();
        foreach (var package in graph.Packages.Values)
        {
            var packageEntry = new Dictionary<string, object>
            {
                ["resolution"] = new Dictionary<string, object>
                {
                    ["integrity"] = package.Integrity,
                    ["tarball"] = package.Resolved
                }
            };

            if (package.Dependencies.Any())
            {
                packageEntry["dependencies"] = package.Dependencies;
            }

            if (package.Dev)
            {
                packageEntry["dev"] = true;
            }

            packages[$"/{package.Name}@{package.Version}"] = packageEntry;
        }

        pnpmLock["packages"] = packages;

        // Serialize to YAML
        var serializer = new SerializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .Build();
        
        return Task.FromResult(serializer.Serialize(pnpmLock));
    }

    private Task<string> GenerateJioLockFileAsync(DependencyGraph graph, CancellationToken cancellationToken)
    {
        var jioLock = new
        {
            version = "1.0",
            name = graph.Name,
            packageVersion = graph.Version,
            dependencies = graph.Dependencies,
            devDependencies = graph.DevDependencies,
            optionalDependencies = graph.OptionalDependencies,
            packages = graph.Packages
        };

        return Task.FromResult(JsonSerializer.Serialize(jioLock, _jsonOptions));
    }

    private void ProcessDependencies(
        Dictionary<string, string> dependencies, 
        Dictionary<string, ResolvedPackage> packages,
        Dictionary<string, List<(string, ResolvedPackage)>> packageGroups)
    {
        foreach (var dep in dependencies)
        {
            var package = packages.Values.FirstOrDefault(p => p.Name == dep.Key);
            if (package != null)
            {
                if (!packageGroups.ContainsKey(package.Name))
                {
                    packageGroups[package.Name] = new List<(string, ResolvedPackage)>();
                }
                packageGroups[package.Name].Add((dep.Value, package));
            }
        }
    }
}