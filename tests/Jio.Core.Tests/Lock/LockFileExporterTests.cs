using System.Text.Json;
using FluentAssertions;
using Jio.Core.Lock;
using Jio.Core.Models;
using Jio.Core.Resolution;
using YamlDotNet.Serialization;

namespace Jio.Core.Tests.Lock;

[Collection("Lock Tests")]
public sealed class LockFileExporterTests : IDisposable
{
    private readonly LockFileExporter _exporter;
    private readonly string _tempDirectory;

    public LockFileExporterTests()
    {
        _exporter = new LockFileExporter();
        _tempDirectory = Path.Combine(Path.GetTempPath(), "jio-lockfile-exporter-tests", Guid.NewGuid().ToString());
        Directory.CreateDirectory(_tempDirectory);
    }

    public void Dispose()
    {
        if (Directory.Exists(_tempDirectory))
        {
            Directory.Delete(_tempDirectory, true);
        }
    }

    [Fact]
    public async Task ExportAsync_WithUnsupportedFormat_ThrowsNotSupportedException()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "test.lock");
        
        var act = async () => await _exporter.ExportAsync(graph, targetPath, (LockFileFormat)999);
        
        await act.Should().ThrowAsync<NotSupportedException>();
    }

    [Fact]
    public async Task ExportAsync_WithJioFormat_CreatesValidJioLockFile()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "jio-lock.json");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Jio);
        
        File.Exists(targetPath).Should().BeTrue();
        
        var content = await File.ReadAllTextAsync(targetPath);
        var lockFile = JsonSerializer.Deserialize<JsonElement>(content);
        
        lockFile.GetProperty("version").GetString().Should().Be("1.0");
        lockFile.GetProperty("name").GetString().Should().Be("test-project");
        lockFile.GetProperty("packages").EnumerateObject().Should().HaveCount(2);
    }

    [Fact]
    public async Task ExportAsync_WithNpmFormat_CreatesValidNpmLockFile()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "package-lock.json");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Npm);
        
        File.Exists(targetPath).Should().BeTrue();
        
        var content = await File.ReadAllTextAsync(targetPath);
        var lockFile = JsonSerializer.Deserialize<JsonElement>(content);
        
        lockFile.GetProperty("name").GetString().Should().Be("test-project");
        lockFile.GetProperty("version").GetString().Should().Be("1.0.0");
        lockFile.GetProperty("lockfileVersion").GetInt32().Should().Be(3);
        lockFile.GetProperty("requires").GetBoolean().Should().BeTrue();
        
        var packages = lockFile.GetProperty("packages");
        packages.EnumerateObject().Should().HaveCount(3); // root + 2 packages
        
        // Check root package
        var rootPackage = packages.GetProperty("");
        rootPackage.GetProperty("name").GetString().Should().Be("test-project");
        rootPackage.GetProperty("dependencies").EnumerateObject().Should().HaveCount(1);
        rootPackage.GetProperty("devDependencies").EnumerateObject().Should().HaveCount(1);
        
        // Check individual packages
        var reactPackage = packages.GetProperty("node_modules/react");
        reactPackage.GetProperty("version").GetString().Should().Be("18.0.0");
        reactPackage.GetProperty("resolved").GetString().Should().Be("https://registry.npmjs.org/react/-/react-18.0.0.tgz");
        reactPackage.GetProperty("integrity").GetString().Should().Be("sha512-test");
    }

    [Fact]
    public async Task ExportAsync_WithYarnFormat_CreatesValidYarnLockFile()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "yarn.lock");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Yarn);
        
        File.Exists(targetPath).Should().BeTrue();
        
        var content = await File.ReadAllTextAsync(targetPath);
        
        content.Should().StartWith("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.");
        content.Should().Contain("# yarn lockfile v1");
        content.Should().Contain("react@^18.0.0:");
        content.Should().Contain("  version \"18.0.0\"");
        content.Should().Contain("  resolved \"https://registry.npmjs.org/react/-/react-18.0.0.tgz\"");
        content.Should().Contain("  integrity test"); // SHA512 prefix removed
        content.Should().Contain("jest@^29.0.0:");
    }

    [Fact]
    public async Task ExportAsync_WithYarnBerryFormat_CreatesValidYarnBerryLockFile()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "yarn.lock");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.YarnBerry);
        
        File.Exists(targetPath).Should().BeTrue();
        
        var content = await File.ReadAllTextAsync(targetPath);
        
        content.Should().Contain("__metadata:");
        content.Should().Contain("  version: 6");
        content.Should().Contain("\"react@npm:^18.0.0\":");
        content.Should().Contain("  version: 18.0.0");
        content.Should().Contain("  resolution: \"react@npm:18.0.0\"");
        content.Should().Contain("  checksum: test");
        content.Should().Contain("  languageName: node");
        content.Should().Contain("  linkType: hard");
    }

    [Fact]
    public async Task ExportAsync_WithPnpmFormat_CreatesValidPnpmLockFile()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "pnpm-lock.yaml");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Pnpm);
        
        File.Exists(targetPath).Should().BeTrue();
        
        var content = await File.ReadAllTextAsync(targetPath);
        
        content.Should().Contain("lockfileVersion: 6.0");
        content.Should().Contain("settings:");
        content.Should().Contain("  autoInstallPeers: true");
        content.Should().Contain("dependencies:");
        content.Should().Contain("devDependencies:");
        content.Should().Contain("packages:");
        content.Should().Contain("/react@18.0.0:");
        content.Should().Contain("/jest@29.0.0:");
    }

    [Fact]
    public async Task ExportAsync_WithEmptyGraph_CreatesValidEmptyLockFile()
    {
        var graph = new DependencyGraph
        {
            Name = "empty-project",
            Version = "1.0.0",
            Dependencies = new Dictionary<string, string>(),
            DevDependencies = new Dictionary<string, string>(),
            OptionalDependencies = new Dictionary<string, string>(),
            Packages = new Dictionary<string, ResolvedPackage>(),
            RootDependencies = new Dictionary<string, string>()
        };
        
        var targetPath = Path.Combine(_tempDirectory, "empty-lock.json");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Jio);
        
        File.Exists(targetPath).Should().BeTrue();
        
        var content = await File.ReadAllTextAsync(targetPath);
        var lockFile = JsonSerializer.Deserialize<JsonElement>(content);
        
        lockFile.GetProperty("name").GetString().Should().Be("empty-project");
        lockFile.GetProperty("packages").EnumerateObject().Should().BeEmpty();
    }

    [Fact]
    public async Task ExportAsync_WithPackageWithDependencies_IncludesDependenciesInAllFormats()
    {
        var graph = CreateGraphWithNestedDependencies();
        
        foreach (var format in Enum.GetValues<LockFileFormat>())
        {
            var extension = format switch
            {
                LockFileFormat.Npm => "package-lock.json",
                LockFileFormat.Yarn => "yarn.lock",
                LockFileFormat.YarnBerry => "yarn-berry.lock",
                LockFileFormat.Pnpm => "pnpm-lock.yaml",
                LockFileFormat.Jio => "jio-lock.json",
                _ => "unknown.lock"
            };
            
            var targetPath = Path.Combine(_tempDirectory, $"{format.ToString().ToLower()}-{extension}");
            
            await _exporter.ExportAsync(graph, targetPath, format);
            
            File.Exists(targetPath).Should().BeTrue($"Lock file should be created for format {format}");
            
            var content = await File.ReadAllTextAsync(targetPath);
            content.Should().NotBeEmpty($"Lock file content should not be empty for format {format}");
            
            // Verify that dependency information is included
            content.Should().Contain("lodash", $"Dependency 'lodash' should be included in {format} format");
        }
    }

    [Fact]
    public async Task ExportAsync_WithOptionalDependencies_IncludesOptionalFlag()
    {
        var graph = CreateTestDependencyGraph();
        // Make jest optional
        graph.Packages["jest@29.0.0"].Optional = true;
        
        var targetPath = Path.Combine(_tempDirectory, "npm-with-optional.json");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Npm);
        
        var content = await File.ReadAllTextAsync(targetPath);
        var lockFile = JsonSerializer.Deserialize<JsonElement>(content);
        
        var jestPackage = lockFile.GetProperty("packages").GetProperty("node_modules/jest");
        jestPackage.GetProperty("optional").GetBoolean().Should().BeTrue();
    }

    [Fact]
    public async Task ExportAsync_WithDevDependencies_IncludesDevFlag()
    {
        var graph = CreateTestDependencyGraph();
        
        var targetPath = Path.Combine(_tempDirectory, "npm-with-dev.json");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Npm);
        
        var content = await File.ReadAllTextAsync(targetPath);
        var lockFile = JsonSerializer.Deserialize<JsonElement>(content);
        
        var jestPackage = lockFile.GetProperty("packages").GetProperty("node_modules/jest");
        jestPackage.GetProperty("dev").GetBoolean().Should().BeTrue();
    }

    [Fact]
    public async Task ExportAsync_WithCancellationToken_RespectsCancellation()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "cancelled.lock");
        
        using var cts = new CancellationTokenSource();
        cts.Cancel();
        
        var act = async () => await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Jio, cts.Token);
        
        await act.Should().ThrowAsync<OperationCanceledException>();
    }

    [Fact]
    public async Task ExportAsync_YarnFormat_HandlesSha1Integrity()
    {
        var graph = CreateTestDependencyGraph();
        graph.Packages["react@18.0.0"].Integrity = "sha1-abcdef123456";
        
        var targetPath = Path.Combine(_tempDirectory, "yarn-sha1.lock");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Yarn);
        
        var content = await File.ReadAllTextAsync(targetPath);
        content.Should().Contain("integrity abcdef123456"); // SHA1 prefix removed
    }

    [Fact]
    public async Task ExportAsync_YarnBerryFormat_HandlesSha1Checksum()
    {
        var graph = CreateTestDependencyGraph();
        graph.Packages["react@18.0.0"].Integrity = "sha1-abcdef123456";
        
        var targetPath = Path.Combine(_tempDirectory, "yarn-berry-sha1.lock");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.YarnBerry);
        
        var content = await File.ReadAllTextAsync(targetPath);
        content.Should().Contain("checksum: abcdef123456"); // SHA1 prefix removed
    }

    [Fact]
    public async Task ExportAsync_PnpmFormat_IncludesSpecifierVersions()
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, "pnpm-specifiers.yaml");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Pnpm);
        
        var content = await File.ReadAllTextAsync(targetPath);
        
        // Parse YAML to verify structure
        var deserializer = new DeserializerBuilder().Build();
        var yaml = deserializer.Deserialize<Dictionary<object, object>>(content);
        
        yaml.Should().ContainKey("dependencies");
        var dependencies = (Dictionary<object, object>)yaml["dependencies"];
        dependencies.Should().ContainKey("react");
        
        var reactDep = (Dictionary<object, object>)dependencies["react"];
        reactDep.Should().ContainKey("specifier");
        reactDep.Should().ContainKey("version");
        reactDep["specifier"].Should().Be("^18.0.0");
        reactDep["version"].Should().Be("18.0.0");
    }

    [Theory]
    [InlineData(LockFileFormat.Npm)]
    [InlineData(LockFileFormat.Yarn)]
    [InlineData(LockFileFormat.YarnBerry)]
    [InlineData(LockFileFormat.Pnpm)]
    [InlineData(LockFileFormat.Jio)]
    public async Task ExportAsync_WithAllFormats_CreatesNonEmptyFiles(LockFileFormat format)
    {
        var graph = CreateTestDependencyGraph();
        var targetPath = Path.Combine(_tempDirectory, $"test-{format.ToString().ToLower()}.lock");
        
        await _exporter.ExportAsync(graph, targetPath, format);
        
        File.Exists(targetPath).Should().BeTrue();
        var fileInfo = new FileInfo(targetPath);
        fileInfo.Length.Should().BeGreaterThan(0);
        
        var content = await File.ReadAllTextAsync(targetPath);
        content.Should().NotBeNullOrWhiteSpace();
    }

    [Fact]
    public async Task ExportAsync_WithScopedPackages_HandlesCorrectly()
    {
        var graph = new DependencyGraph
        {
            Name = "test-scoped",
            Version = "1.0.0",
            Dependencies = new Dictionary<string, string>
            {
                ["@babel/core"] = "^7.20.0"
            },
            DevDependencies = new Dictionary<string, string>(),
            OptionalDependencies = new Dictionary<string, string>(),
            Packages = new Dictionary<string, ResolvedPackage>
            {
                ["@babel/core@7.20.0"] = new ResolvedPackage
                {
                    Name = "@babel/core",
                    Version = "7.20.0",
                    Resolved = "https://registry.npmjs.org/@babel/core/-/core-7.20.0.tgz",
                    Integrity = "sha512-test",
                    Dependencies = new Dictionary<string, string>(),
                    Dev = false,
                    Optional = false
                }
            },
            RootDependencies = new Dictionary<string, string>()
        };
        
        var targetPath = Path.Combine(_tempDirectory, "scoped-packages.json");
        
        await _exporter.ExportAsync(graph, targetPath, LockFileFormat.Npm);
        
        var content = await File.ReadAllTextAsync(targetPath);
        content.Should().Contain("@babel/core");
        content.Should().Contain("node_modules/@babel/core");
    }

    private DependencyGraph CreateTestDependencyGraph()
    {
        return new DependencyGraph
        {
            Name = "test-project",
            Version = "1.0.0",
            Dependencies = new Dictionary<string, string>
            {
                ["react"] = "^18.0.0"
            },
            DevDependencies = new Dictionary<string, string>
            {
                ["jest"] = "^29.0.0"
            },
            OptionalDependencies = new Dictionary<string, string>(),
            Packages = new Dictionary<string, ResolvedPackage>
            {
                ["react@18.0.0"] = new ResolvedPackage
                {
                    Name = "react",
                    Version = "18.0.0",
                    Resolved = "https://registry.npmjs.org/react/-/react-18.0.0.tgz",
                    Integrity = "sha512-test",
                    Dependencies = new Dictionary<string, string>(),
                    Dev = false,
                    Optional = false
                },
                ["jest@29.0.0"] = new ResolvedPackage
                {
                    Name = "jest",
                    Version = "29.0.0",
                    Resolved = "https://registry.npmjs.org/jest/-/jest-29.0.0.tgz",
                    Integrity = "sha512-test2",
                    Dependencies = new Dictionary<string, string>(),
                    Dev = true,
                    Optional = false
                }
            },
            RootDependencies = new Dictionary<string, string>()
        };
    }

    private DependencyGraph CreateGraphWithNestedDependencies()
    {
        return new DependencyGraph
        {
            Name = "nested-deps",
            Version = "1.0.0",
            Dependencies = new Dictionary<string, string>
            {
                ["express"] = "^4.18.0"
            },
            DevDependencies = new Dictionary<string, string>(),
            OptionalDependencies = new Dictionary<string, string>(),
            Packages = new Dictionary<string, ResolvedPackage>
            {
                ["express@4.18.0"] = new ResolvedPackage
                {
                    Name = "express",
                    Version = "4.18.0",
                    Resolved = "https://registry.npmjs.org/express/-/express-4.18.0.tgz",
                    Integrity = "sha512-express",
                    Dependencies = new Dictionary<string, string>
                    {
                        ["lodash"] = "^4.17.21"
                    },
                    Dev = false,
                    Optional = false
                },
                ["lodash@4.17.21"] = new ResolvedPackage
                {
                    Name = "lodash",
                    Version = "4.17.21",
                    Resolved = "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
                    Integrity = "sha512-lodash",
                    Dependencies = new Dictionary<string, string>(),
                    Dev = false,
                    Optional = false
                }
            },
            RootDependencies = new Dictionary<string, string>()
        };
    }
}